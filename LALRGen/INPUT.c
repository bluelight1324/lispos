/* input.c ---  Page 39                                            */

#pragma warning(disable:4115)
#pragma warning(disable:4244)
#pragma warning(disable:4057)
#pragma warning(disable:4211)
#pragma warning(disable:4220)

//#include <standard.h>
#include <windows.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <tchar.h>
#include "debug.h"
#include <string.h>        /* " */


extern _TINT  ii_flush(_TINT force );
extern _TINT  ii_fillbuf(_TCHAR * );
extern _TINT  FError(_TCHAR *fmt, ...);


/*------------------------------------------------------------------------
 * INPUT.C:  The input system used by LeX- generated lexical analyzers.
 *-----------------------------------------------------------------------
 * System-dependent defines.
 */

 #ifdef MSDOS
 #        define  COPY(d,s,a) memmove(d,s,a)
 #elif defined _WIN32
 #        define  COPY(d,s,a) memmove(d,s,a)
 #else
 #        define  COPY(d,s,a) memcpy(d,s,a)
 #endif

 #define  STDIN    0       /* standard input   */
 
 /*--------------------------------------------------------------------*/
 
 #define MAXLOOK     16             /* Max. amount of lookahead       */
 #define MAXLEX      1024           /* Max. lexeme sizes              */
 
 /* :CC below 3->100 */
 #define BUFSIZE  ( (MAXLEX * 100) + (2 * MAXLOOK) )  /* Prev Val. 3. Change the 3 only */   

 #define DANGER   ( End_buf - MAXLOOK )  /* Flush buffer when Next */
                                         /* passes this address    */
                                         
#define END       (&Start_buf[BUFSIZE])  /* Just past last _TCHAR in buf */

#define NO_MORE_CHARS()  ( Eof_read && Next >= End_buf )

//typedef unsigned _TCHAR   uchar;

static  _TUCHAR  Start_buf[BUFSIZE];  /* Input buffer                    */
static  _TUCHAR  *End_buf  = END;     /* Just past last character        */
static  _TUCHAR  *Next     = END;     /* Next input character            */
static  _TUCHAR  *sMark    = END;     /* Start of current lexeme         */
static  _TUCHAR  *eMark    = END;     /* End of current lexeme           */
static  _TUCHAR  *pMark    = NULL;    /* Start of previous lexeme        */
static  _TINT    pLineno   = 0;       /* Line # of previous lexeme       */                              
static  _TINT    pLength   = 0;       /* Length of previous lexeme       */

static  _TINT    Inp_file  = STDIN;   /* Input file handle               */
static  _TINT    Lineno    = 1 ;      /* Current line number             */
static  _TINT    Mline     = 1 ;      /* Line # when mark_end() called   */
static  _TINT    Termchar  = 0 ;      /* Holds the character that was    */
                                     /* overwritten bu a \0 when we     */
									 /* null terminated the last lexeme */
static  _TINT    Eof_read  = 0;       /* End of file has been read       */
                                     /* It's possible for this to be    */
									 /* true and for characters to      */
									 /* still be in the input buffer    */

/*extern int _topen(const _TCHAR*,int,...),
       _close(int), 
       _read(int,void *,int);*/

//static int (*Openp)(const _TCHAR*,int)  = (int (*)(const _TCHAR*,int))_topen  ;         /* Pointer to open function        */
//static int (*Closep)(int) = _close ;                     /* Pointer to close function       */
//static int (*Readp)(int,void *,unsigned int)  = _read  ; /* Pointer to read function        */
static int (*Openp)()  = _topen  ;         /* Pointer to open function        */
static int (*Closep)() = _close ;                     /* Pointer to close function       */
static int (*Readp)()  = _read  ; /* Pointer to read function        */



/* input.c -- Initialization Routines   Pg. 41                           */

void   ii_io(int (*open_funct)(),int (*close_funct)(),int (*read_funct)() )
{
    /* This function lets you modify the open(), close(), and read()
	 * functions used by the i/o system. Your own routines must work
	 * like the real open, close and read( at least in terms of the 
	 * external interface. Open should return a number that can't be
	 * confused with standard input ( not 0 ).
	 */

	 Openp  = open_funct;
	 Closep = close_funct;
	 Readp  = read_funct;
}
/*---------------------------------------------------------------------*/
_TINT     ii_newfile(_TCHAR *name)
{
    /* Prepare a new input file for reading. If newfile() isn't called before
	 * input() or input_line() then stdin is used. The current input file 
	 * is closed after successfully opening the new one( but stdin isn't
	 * closed).
	 *
	 * Return -1 if the file can't be opened; otherwise, return the file
	 * descriptor returned from open(). Note that the old input file
	 * won't be closed unless the new file is opened successfully. The
	 * error code (errno) generated by the bad open() will still be valid
	 * so you can call perror() to find out what went wrong. At least one
	 * free file descriptor must be available when newfile() is called
	 * Note in the open call that O_BINARY, which is needed in MS-DOS
	 * applications, is mapped to 0 under UNIX(with a define in 
	 * <tools/debug.h>.
	 */

	 _TINT fd;             /* file descriptor    */

	 MS( if( _tcscmp(name, _T("/dev/tty")) == 0 )    )
	 MS(        name = _T("CON") ;					)

	 if( (fd = !name ? STDIN : (*Openp)(name, O_RDONLY|O_BINARY)) != -1 )
	 {
	      if( Inp_file != STDIN )
		       (*Closep)( Inp_file );

		  Inp_file = fd;
		  Eof_read = 0;

		  Next    = END;
		  sMark   = END;
		  eMark   = END;
		  End_buf = END;
		  Lineno  = 1;
		  Mline   = 1;
	 }
	 return fd;
}

/* Small Acess Routines and Marker Movement        Pg.43                */

 _TCHAR *ii_text        () { return( (_TCHAR *)sMark          ); }
 _TINT   ii_length      () { return( eMark - sMark  ); }
 _TINT   ii_lineno      () { return( Lineno         ); }
 _TCHAR *ii_ptext       () { return( (_TCHAR *)pMark          ); }
 _TINT   ii_plength     () { return( pLength        ); }
 _TCHAR  ii_plineno     () { return( pLineno        ); }

_TCHAR *ii_mark_start()
{
   Mline = Lineno;
   eMark = sMark = Next;
   return( (_TCHAR *)sMark );
}


  _TCHAR *ii_mark_end()
{
   Mline = Lineno ;
   return((_TCHAR *)(eMark = Next) );
}


  _TCHAR *ii_move_start()
{
    if( sMark >= eMark )
	    return NULL;
	else
	    return  (_TCHAR *)++sMark;
}

  _TCHAR *ii_to_mark()
{
    Lineno = Mline ;
	return( (_TCHAR *)(Next = eMark) );
}


_TCHAR * ii_mark_prev()
{
   /* Set the pMark. Be careful with this routine. A buffer flush won't go
    * past pMark so, once you've set it, you must move it every time you
	* move sMark. I'm not doing this automatically because I might want
	* to remember the token before last  rather than the last one. I ii_mark_prev()
	* is never called, pMark is just ignored and you don't have to worry
	* about it
	*/

	pMark   = sMark;
	pLineno = Lineno;
	pLength = eMark - sMark;
	return( (_TCHAR *)pMark );
}


/* The Advance Function pg. 44                                        */

_TINT       ii_advance()
{
    /* ii_advance() is the real input function. It returns the next 
	 * character from input and advances past it. The buffer is flushed
	 * if the current character is within MAXLOOK characters of the end
	 * of the buffer. 0 is returned at end of file. -1 is returned if the
	 * buffer  can't be flushed because it's too full. In this case you 
	 * can call ii_flush() to do a buffer flush but you'll loose the 
	 * current lexeme as a consequence.
	 */

    static  _TINT been_called;
    
    if( !been_called )
    {
       /* Push a newline into the empty buffer so that
        * the Lex start-of-line anchor will work on the
        * first input line.
        */

       Next  = sMark = eMark = END - 1;
       *Next = '\n';
       --Lineno;
       --Mline ;
       been_called = 1;
    }

    if( NO_MORE_CHARS() )
        return 0;

    if( !Eof_read  && ii_flush(0) < 0 )
        return -1;

    if( *Next == '\n' )
        ++Lineno;

	return( *Next++ );
}


/* Buffer Flushing pg.45                                               */

_TINT  ii_flush(_TINT  force)
{
   /* See page 45 for comments  */

   _TINT   copy_amt, shift_amt;
   _TUCHAR *left_edge;

   if( NO_MORE_CHARS() )
       return 0;

   if( Eof_read )                /* nothing more to read  */
       return 1;

   if( Next >= DANGER  || force )
   {
       left_edge = pMark ? min(sMark, pMark) : sMark;
	   shift_amt = left_edge - Start_buf;

	   if( shift_amt < MAXLEX )   /* if not enough room  */
	   {
	       if( !force )
		       return -1;

		   left_edge = (_TCHAR*)ii_mark_start();  /* Reset start to current character */
		   ii_mark_prev();
		   shift_amt = left_edge - Start_buf;
	   }

	   copy_amt = End_buf - left_edge;
	   COPY( Start_buf, left_edge, copy_amt );

	   if( !ii_fillbuf( Start_buf + copy_amt) )
	       FError(_T("INTERNAL ERROR, ii_flush: Buffer full, can't read.\n"));

	   if( pMark )
	       pMark -= shift_amt;

	   sMark -= shift_amt;
	   eMark -= shift_amt;
	   Next  -= shift_amt;
   }

   return 1;
}

/*-------------------------------------------------------------------*/

static  _TINT   ii_fillbuf( _TCHAR *starting_at )
{
    extern _TINT Verbose;
   /*
    * See comment on page 46
	*/

	register unsigned need,    /* Number of bytes required from input */
	                  got;     /* Number of bytes actually read       */

	need = ((END - starting_at) / MAXLEX) * MAXLEX ;

    if( Verbose )
	   D( _tprintf(_T("Reading %d bytes\n"), need );   )

	if( need < 0 )
	    FError(_T("INTERNAL ERROR (ii_fillbuf): Bad read-request starting addr.\n"));

    if( need == 0 )
	    return 0;

	if( ( got = (*Readp)(Inp_file, starting_at, need)) == -1 )
	      FError(_T("Can't read input file\n"));

	End_buf = starting_at + got;

	if( got < need && eof(Inp_file))
	    Eof_read = 1;                 /* At end of file  */

	return got;
}

/* Lookahead														*/

_TINT   ii_look(_TINT  n )
{
    /* Return the nth character of lookahead, EOF if you try to look past
	 * end of file, or 0 if you try to look past either end of the
	 * buffer
	 */

	 _TUCHAR     *p;

	 p = Next + (n-1) ;

	 if( Eof_read && p >= End_buf )
	     return EOF;

	 return( p < Start_buf || p >= End_buf ) ? 0 : *p;
}


_TINT   ii_pushback(_TINT n )
{
  /* Push n characters back into the input. You can't push past the 
   * current sMark. You can, however, push back characters after end 
   * of file has been encountered.
   */
   
   while( --n >= 0 && Next > sMark )
   {
       if( *--Next == '\n'  || !*Next )
           --Lineno;
   }
    
   if( Next < eMark )
   {
       eMark = Next;
       Mline = Lineno;
   }
   
   return( Next > sMark );
}                    


/* Support for '\0' terminated strings                                */

void   ii_term()
{
    Termchar  = *Next;
	*Next     = '\0' ;
}

/*---------------------------------------------------------------------*/

void   ii_unterm()
{
    if( Termchar )
	{ 
	    *Next = Termchar;
		Termchar = 0;
	}
}

/*---------------------------------------------------------------------*/

_TINT  ii_input()
{
   _TINT rval;

   if( Termchar )
   {
       ii_unterm();
	   rval = ii_advance();
	   ii_mark_end();
	   ii_term();
   }
   else
   {
       rval = ii_advance();
	   ii_mark_end();
   }

   return rval;
}

/*----------------------------------------------------------------------*/

void  ii_unput( _TINT c )
{
    if( Termchar )
	{
	    ii_unterm();
		if( ii_pushback(1) )
		    *Next = c;
		ii_term();
	}
	else
	{
	    if( ii_pushback(1) )
		    *Next = c;
	}
}

/*----------------------------------------------------------------------*/

_TINT     ii_lookahead(_TINT n )
{
    return( n == 1 && Termchar) ? Termchar : ii_look(n) ;
}

/*----------------------------------------------------------------------*/

_TINT    ii_flushbuf()
{
    if( Termchar )
	    ii_unterm();

	return ii_flush(1);
}

