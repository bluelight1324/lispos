
#include <windows.h>
//#include <standard.h>
#include  <stdio.h>
#include  <stdarg.h>
#include  "debug.h"
#include  <tchar.h>
#include  "set.h"


/*#define CREATING_LLAMA_PARSER */ /* Suppress various defn. in parser.h that */
#include "hash.h"            /* conflict with llama-generated defns. */


/* This file is a llama input file that creates a parser for llama, like
 * a snake eating its tail.The resulting yyparse.c file can be used in 
 * place of the recursive-descent parser in llpar.c.Most of the 
 * external subroutines called from this module are in acts.c.
 * Exceptions are:
 */

 extern _TCHAR  *yytext;      /* Generated by lex  */
 extern _TINT   yylineno;     /* Generated by lex  */
 extern void  nows(),ws();  /* Declared in llama.lex */

 #define  YYSTYPE  _TCHAR*    /* Value-stack type      */
 #include "synyyout.h"

#define  YYACTION
#define  YYPARSER
/* occs.par--- File Header    Page   385                      */

#include "yystack.h"
#include  "def.h"

/********************Extern Declarations ********************************/
extern  _TINT      FError(_TCHAR *fmt,...);
extern  void       first_sym();
extern  void union_def(_TCHAR *action );
extern  void new_lev(_TINT how );
extern  void new_rhs();
extern  SYMBOL  *make_term(_TCHAR *name );
extern  void add_synch(_TCHAR *yytext);
extern  _TINT start_action();
extern  void add_to_rhs(_TCHAR *object,_TINT is_an_action );
extern   void prec(_TCHAR *name );
extern    void start_opt(_TCHAR *lex );
extern    void end_opt(_TCHAR *lex );
extern    void prec_list(_TCHAR *name );
extern    SYMBOL   *new_nonterm(_TCHAR *name,_TINT is_lhs );
extern   void new_field(_TCHAR *field_name ); 
extern    void lerror(_TINT fatal,_TCHAR *fmt, ... );
extern  _TCHAR * ii_mark_prev();
extern  _TINT  yylex(void);

  _TINT yynerrs = 0;    /* Total error count          */

/***********************************************************************/

// FILE  *stdout = stdout  ; /* Output stream for code                */
// FILE  *yybssout  = stdout  ; /* Output stream for initialized data    */
// FILE  *yydataout = stdout  ; /* Output stream for uninitialized data  */
 _TINT   yylookahead ;          /* Lookahead token                       */


 extern  _TCHAR  *yytext;       /* Declared by lex in lexyy.c          */
 extern  _TINT   yylineno;
 extern  _TINT   yyleng;
 extern  _TINT   separator_count;

 extern _TCHAR  *ii_ptext() ;        /* Lookback function used by lex  */
 extern _TINT   ii_plength();        /* in input.c                     */
 extern _TCHAR  ii_plineno();
 

 #ifdef YYDEBUG                 /* Define YYd here so that it can be used */
 #   define  YYD(x) x           /* in the user-supplied header.*/            
 #else
 #   define  YYD(x)  /* empty */
 #endif

/*-----------------------------------------------------------------------
 * occs.par-- Definitions  Page  386
 */

 #undef  YYD                    /* Redefine YYD in case YYDEBUG was defined  */
 #ifdef  YYDEBUG                /* explicitly in the header rather than with */
 #   define  YYD(x) x           /* a -D on the occs command line             */
 #   define  printf  yycode     /* Make printf() calls got to output window  */
 #else
 #   define  YYD(x)  /* empty */
 #endif

 #ifndef YYACCEPT
 #     define YYACCEPT  return(0)   /* Action taken when input is accepted */
 #endif

 #ifndef YYABORT
 #    define  YYABORT  return(1)    /* Action taken when input is rejected */
 #endif

 #ifndef YYPRIVATE
 #    define  YYPRIVATE static       /* define to a null string to make public */
 #endif

 #ifndef YYMAXERR
 #    define YYMAXERR 25            /* Abort after this many errors       */
 #endif


/* 	YYMAXDEPTH has been set to the  value of 1 MB                 */
 #ifndef  YYMAXDEPTH
 #    define YYMAXDEPTH  1024 * 1024  	/* State and value stack depth        */
 #endif                                 /* Original value 128 bytes           */

 #ifndef  YYCASCADE
 #    define YYCASCADE  5           /* Suppress error messages for this many cycles */
 #endif

								    /* Default  value stack type         */
 #ifndef YYSTYPE
 #    define YYSTYPE _TINT                 
 #endif

 #ifndef YYSHIFTACT 
 #    define YYSHIFTACT(tos)   ( (tos)[0] = yylval )
 #endif


 #ifndef YYVERBOSE
 #    define   YYV(x)  x                    
 #else
 #    define  YYV(x)
 #endif
								   /* redefine stack macros for local use */
 #undef  yystk_cls
 #define yystk_cls  YYPRIVATE 


 /* see comment here page 387                  */


 #define YY_IS_ACCEPT     0
 #define YY_IS_SHIFT(s)   ((s) > 0 )


 /* Note: YY_TTYPE must be signed because parser tables use negative values for reduce actions */
 #ifndef YY_TTYPE_DEFINED
 typedef int  YY_TTYPE;
 #define YY_TTYPE_DEFINED
 #endif
 #define  YYF   ((YY_TTYPE)( (unsigned short) ~0 >>1 ))

 /* see comment here page 387                        */

 #if  !defined(YYACTION) || !defined(YYPARSER)
 #     define  YYP
 #else
 #     define YYP  YYPRIVATE
 #endif

 /* YYPRIVATE _TINT  yynerrs = 0;  */ /*yynerrs already defined */                

 yystk_dcl( Yy_stack, _TINT, YYMAXDEPTH );

	 YYSTYPE  yylval;
YYP  YYSTYPE  Yy_val;
YYP  YYSTYPE  Yy_vstack[ YYMAXDEPTH ];
YYP  YYSTYPE  *Yy_vsp;

YYP  _TINT      Yy_rhslen;

typedef struct           /* Typedef for value-stack elements */
{
	YYSTYPE  left;       /* Holds value of left-hand side attribute */
	YYSTYPE  right;      /* Holds value of current-symbol's attribute */             

} yyvstype;

extern YY_TTYPE  *Yy_action[]; /* Forward Reference */ 
extern YY_TTYPE  *Yy_goto[];   /* Forward Reference */  
extern _TINT Yy_lhs[];           /* Forward Reference */  
extern _TCHAR  *Yy_stok[];       /* Forward Reference */  
extern _TINT Yy_reduce[];        /* Forward Reference */  

void yy_init_occs(YYSTYPE *yylval);
_TINT  yy_act(_TINT yypnum,YYSTYPE *yyvsp );


#ifdef  YYDEBUG
  extern   _TCHAR  *Yy_slhs[];
  extern   _TCHAR  *Yy_srhs[];
#endif



/*-------------------------------------------------------------------------
 * Table-Decompression and Output Subroutines      Page 394            
 */

YYPRIVATE YY_TTYPE yy_next(YY_TTYPE **table,YY_TTYPE cur_state,_TINT inp)

{
   /* Next-state routine for the compressed tables. Given current state and
	* input symbol (inp), return next state.
	*/

	YY_TTYPE   *p = table[ cur_state ] ;
	_TINT        i;

	if( p )
    {
        i = (_TINT) *p++;
		for( ; --i >= 0; p +=2 )
			 if( inp == p[0] )
				  return p[1];
    }

	return YYF;
}

/*-----------------------------------------------------------------------*/

yystk_dcl( Yy_dstack, _TCHAR *, YYMAXDEPTH );      /* Symbol stack   */

#ifdef  YYDEBUG
yycode(_TCHAR *fmt)
{
		va_list  args;
		va_start( args,       fmt );
		yy_output( 0, fmt, args );
}



yydata(_TCHAR *fmt)
{
		va_list    args;
		va_start( args,      fmt );
		yy_output( 1, fmt, args );
}


yybss(_TCHAR *fmt)
{
		va_list    args;
		va_start( args,      fmt );
		yy_output( 2 , fmt, args );
}


/* yycomment() and yyerror() are defined in yydebug.c                  */

#else  /*---------------------------------------------------------------*/

#define  yy_nextoken()      yylex()     /* when YYDEBUG isn't defined  */
#define  yy_quit_debug()
#define  yy_init_debug()
#define  yy_pstack(x,y)
#define  yy_sym()

/* see comment here page 395                                      */

//void yycode(_TCHAR *fmt)
void yycode(_TCHAR *fmt,...) //CHANGED MN 
{
		va_list  args;
		va_start( args,       fmt );
		_vftprintf( stdout, fmt, args );
}



//void yydata(_TCHAR *fmt)
void yydata(_TCHAR *fmt,...) //CHANGED MN 
{
		va_list    args;
		va_start( args,      fmt );
		_vftprintf( stdout, fmt, args );
}


//void yybss(_TCHAR *fmt)
void yybss(_TCHAR *fmt,...) //CHANGED MN 
{
		va_list    args;
		va_start( args,      fmt );
		_vftprintf( stdout , fmt, args );
}

//void    yycomment(_TCHAR *fmt)
void    yycomment(_TCHAR *fmt,...) //CHANGED MN
{
		va_list    args;
		va_start( args,      fmt );
		_vftprintf( stdout   , fmt, args );
}


void    yyerror(_TCHAR *fmt, ... )
{
		extern _TCHAR  *yytext;
		extern _TINT   yylineno;
		va_list   args;
		
		va_start( args, fmt );
		_ftprintf(  stderr, _T("ERROR( line %d near %s): "), yylineno, yytext );
		_vftprintf( stderr, fmt, args );
		_ftprintf( stderr, _T("\n") );
}

#endif


/* The parser    Page 396                                              */

YYPRIVATE  void yy_shift(_TINT new_state,_TINT lookahead )
{
   yypush( Yy_stack, new_state );
   --Yy_vsp;
   YYSHIFTACT( Yy_vsp );


   #ifdef YYDEBUG
	   yycomment( "Shift %0.16s (%d)\n", Yy_stok[ lookahead ], new_state);
	   yypush_  (Yy_dstack, Yy_stok[lookahead] );
	   yy_pstack(0, 1);
   #endif
}


/*-----------------------------------------------------------------------*/

YYPRIVATE  void yy_reduce(_TINT prod_num,_TINT amount)
{
   _TINT   next_state;

   yypopn( Yy_stack, amount );
   Yy_vsp += amount;
   *--Yy_vsp = Yy_val;

   next_state = yy_next( Yy_goto, yystk_item(Yy_stack,0), Yy_lhs[prod_num] );

#ifndef  YYDEBUG

   yypush_ ( Yy_stack, next_state );

#else

	yy_break( prod_num );            /* activate production breakpoint  */
	yypopn_ ( Yy_dstack, amount );

   YYV( yycomment("   pop %d item%s\n", amount, amount==1 ? "" : "s"); )
   yy_pstack( 0, 0 );
   yypush_( Yy_stack, next_state               );
   yypush_( Yy_dstack, Yy_slhs[ prod_num ] );

   YYV( yycomment("      push %0.16s (%d)", Yy_slhs[prod_num], next_state ); )

   yy_pstack( 0, 1 );

#endif
}

/*----------------------------------------------------------------------*/

YYPRIVATE    void  yy_init_stack()     /* Initialize the stacks  */
 {
	yystk_clear( Yy_stack );
	yypush_    ( Yy_stack,  0 );       /* State stack = 0   */

	Yy_vsp = Yy_vstack + (YYMAXDEPTH-1); /* Value stack = garbage  */


 #  ifdef  YYDEBUG
	yystk_clear   ( Yy_dstack );
	yypush_       ( Yy_dstack, "$" );
	yycomment     ( "Shift start state\n" );   
	yy_pstack     (0, 1);                /* refresh stack window    */
 #endif
}

/*----------------------------------------------------------------------*/

YYPRIVATE    _TINT  yy_recover(_TINT tok,_TINT suppress )
{
   
   _TINT       *old_sp   = yystk_p(Yy_stack);
   YYD( _TCHAR **old_dsp = yystk_p(Yy_dstack);   )
   YYD( _TCHAR  *tos;                            )
   
   
   if( !suppress )
   {
	   yyerror(_T( "Unexpected %s\n"), Yy_stok[tok] );
	   if( ++yynerrs > YYMAXERR )
	   {
		   yyerror(_T("Too many errors aborting\n"));
		   return 0;
	   }
   }
   
   do {
	
	   while( !yystk_empty(Yy_stack)
					&& yy_next( Yy_action, yystk_item(Yy_stack,0), tok) ==YYF )
	   {
		  
		  yypop_( Yy_stack );
		  
		  YYD( tos = yypop_(Yy_dstack); )
		  YYD( yycomment("Popping %d from state stack\n", tos); )
		  YYD( yy_pstack(0,1 ); )
	   }
	   
	  if( !yystk_empty(Yy_stack) )
	  {
	  
	  Yy_vsp = Yy_vstack + (yystk_ele(Yy_stack) -1);
	  
	  #ifdef YYDEBUG
		   yystk_p(yy_dstack) = Yy_dstack + (yystk_ele(Yy_stack) -1);
		   yycomment("Error recovery successful\n" );
		   yy_pstack(0, 1);
	  #endif
	  
	  return tok;
   }
   
	yystk_p( Yy_stack ) = old_sp;
   
   YYD( yystk_p( Yy_dstack ) = old_dsp ;                       )
   YYD( yycomment("Restoring state stack. ");                  )
   YYD( yy_pstack(1, 1);                                       )
   YYD( yycomment("Discarding %s\n", Yy_stok[tok]);    )

} while( ii_mark_prev(), tok = yy_nextoken() );



  YYD( yycomment("Error recovery failed\n"); )
  return 0;
}


/*----------------------------------------------------------------------*/

_TINT    yyparse()
{
   /* General-purpose  LALR parser. Return 0 normally or -1 if the error
	* recovery fails. Any other value is supplied by the user as a return
	* statement in an action
	*/

	int    act_num;                /* Contents of current parse table entry (must be signed!) */
	_TINT  icount=0;
	_TINT  errcode;       /* Error code returned from yy_act()          */
	_TINT  tchar  ;       /* Use to \0-terminate the lexeme             */
	_TINT  suppress_err;  /* Set to YYCASCADE after an error is found   */
						/* and decremented on each parse cycle. Error */
						/* messages aren't printed if it's true       */

#ifdef  YYDEBUG
	if ( !yy_init_debug( Yy_stack,  &yystk_p(Yy_stack ),
						 Yy_dstack, &yystk_p(Yy_dstack),
						 Yy_vstack, sizeof(YYSTYPE), YYMAXDEPTH) )
		 YYABORT;
#endif

   yy_init_stack ();     /* Initialize  parse stack                */
   yy_init_occs ( Yy_vsp );
   yylookahead  = yy_nextoken();   /* Get first input symbol   */
   suppress_err = 0;
   while( 1 )
   {
	  /*  Below code added                                            */
      if (separator_count == 2)
         break;

	  else
	  if( yylookahead == WHITESPACE )
	  {
		 nows();
		 yylookahead  = yy_nextoken();
		 continue;
	  }
	  /*   Above code added                                           */

	  act_num = yy_next( Yy_action, yystk_item(Yy_stack,0), yylookahead );

	  if( suppress_err )
		  --suppress_err;

	  if( act_num == YYF )
	  {
		 if( !(yylookahead = yy_recover( yylookahead, suppress_err )) )
			 YYABORT;
			 
		 suppress_err = YYCASCADE;
	  }
	  else if( YY_IS_SHIFT(act_num) )           /* Simple shift action */
	  {
		/* See comment here page 399                         */

		yy_shift( act_num, yylookahead );
		
		ii_mark_prev();
		yylookahead = yy_nextoken();
	  }
	  else
	  {
		/* see comment here page 399      */

 		act_num     = -act_num;
		Yy_rhslen   = Yy_reduce[ act_num];
		Yy_val      = Yy_vsp[ Yy_rhslen ? Yy_rhslen-1 : 0 ];  /* $$ = $1 */

		yylineno        = ii_plineno();
		yytext          = ii_ptext  ();
		tchar           = yytext[ yyleng = ii_plength() ];
		yytext[yyleng]  = '\0';

		YYD( yycomment("Reduce by (%d) %s->%s\n", act_num, \
									Yy_slhs[act_num], Yy_srhs[act_num]); )

		if( errcode = yy_act( act_num, Yy_vsp ) )
			return errcode;

		ii_ptext()[ ii_plength() ] = tchar;          /* (2) */

		if( act_num  == YY_IS_ACCEPT )
			break;
		else
			yy_reduce( act_num, Yy_rhslen );
	 }
  }
  YYD( yycomment( "Accept\n" );    )
  YYD( yy_quit_debug();            )
  
  YYACCEPT;
}   

											  

_TINT yy_act(_TINT yypnum,YYSTYPE *yyvsp )
/*_TINT             yypnum;                   production number  
YYSTYPE         *yyvsp;                    value-stack pointer */
{
   /* This subroutine holds all the actions in the original input
    * specification. It normally returns 0, but if any of your
    * actions return a non-zero number, then the parser halts
    * immediately , returning that nonzero number to the calling
    * subroutine.
    */

    switch( yypnum )
    {

    case 39: /* fnames -> FIELD {14} fnames  */

	{ new_field   (yytext);    }
              break;

    case 40: /* fnames -> NAME {13} fnames  */

	{ new_nonterm (yytext,0);  }
              break;

    case 41: /* pnames -> FIELD {18} pnames  */

	{ new_field(yytext);  }
              break;

    case 42: /* pnames -> NAME {17} pnames  */

	{ prec_list(yytext);  }
              break;

    case 43: /* rhs -> START_OPT {27} rhs END_OPT {28} rhs  */

	{ end_opt  (yytext  ); }
              break;

    case 44: /* rhs -> START_OPT {27} rhs END_OPT {28} rhs  */

	{ start_opt( yytext ); }
              break;

    case 45: /* rhs -> PREC NAME {26} rhs  */

	{ prec      (yytext                ); }
              break;

    case 46: /* rhs -> ACTION {25} rhs  */

	{ 	
 	 add_to_rhs(yytext,start_action() ); }
              break;

    case 47: /* rhs -> FIELD {24} rhs  */

	{ add_to_rhs(yytext, 0             ); }
              break;

    case 48: /* rhs -> NAME {23} rhs  */

	{ add_to_rhs(yytext, 0             ); }
              break;

    case 49: /* snames -> NAME {19} snames  */

	{ add_synch(yytext); }
              break;

    case 50: /* tnames -> FIELD {16} tnames  */

	{ new_field(yytext);  }
              break;

    case 51: /* tnames -> NAME {15} tnames  */

	{ make_term(yytext);  }
              break;

    case 52: /* right_sides -> {22} rhs end_rhs  */

	{ new_rhs(); }
              break;

    case 53: /* defs -> START {12} opt_names defs  */

	{
				  lerror( NONFATAL,
							_T("%start not supported by occs. The first\n")
							_T("\t\t\tproduction is the start production\n"));
			  }
              break;

    case 54: /* defs -> NONASSOC {10} pnames {11} defs  */

	{new_field(_T(""));}
              break;

    case 55: /* defs -> NONASSOC {10} pnames {11} defs  */

	{ new_lev ('n'); }
              break;

    case 56: /* defs -> RIGHT {8} pnames {9} defs  */

	{new_field(_T(""));}
              break;

    case 57: /* defs -> RIGHT {8} pnames {9} defs  */

	{ new_lev (_T('r')); }
              break;

    case 58: /* defs -> LEFT {6} pnames {7} defs  */

	{new_field(_T(""));}
              break;

    case 59: /* defs -> LEFT {6} pnames {7} defs  */

	{ new_lev (_T('l')); }
              break;

    case 60: /* defs -> TERM_SPEC {4} tnames {5} defs  */

	{new_field(_T(""));}
              break;

    case 61: /* defs -> TERM_SPEC {4} tnames {5} defs  */

	{ new_lev ( 0 ); }
              break;

    case 62: /* defs -> TYPE fnames {3} defs  */

	{new_field(_T(""));}
              break;

    case 63: /* defs -> PERCENT_UNION ACTION {2} defs  */

	{ union_def( yytext ); }
              break;

    case 64: /* spec -> defs SEPARATOR {0} rules end  */

	{ first_sym();  }
              break;

    case 65: /* rule -> FIELD {21} COLON right_sides  */

	{ new_nonterm(yytext,1); }
              break;

    case 66: /* rule -> NAME {20} COLON right_sides  */

	{ new_nonterm(yytext,1); }
              break;

    case 67: /* end -> {1} SEPARATOR  */

	{ ws();}
              break;


      #ifdef  YYDEBUG

          default: yycomment(_T("Production %d: no action\n"), yypnum);
                break;
      #endif
      }

      return 0;
}

/*---------------------------------------------------------
 * Yy_stok[] is used for debugging and error messages. It is indexed
 * by the internal value used for a token (as used for a column index in
 * the transition matrix) and evaluates to a string naming that token
 */

_TCHAR  *Yy_stok[] =
{
	/*    0 */  _T( "__EOI_ "),
	/*   1 */   _T("ACTION"),
	/*   2 */   _T("CODE_BLOCK"),
	/*   3 */   _T("COLON"),
	/*   4 */   _T("END_OPT"),
	/*   5 */   _T("FIELD"),
	/*   6 */   _T("LEFT"),
	/*   7 */   _T("NAME"),
	/*   8 */   _T("NONASSOC"),
	/*   9 */   _T("OR"),
	/*  10 */   _T("OTHER"),
	/*  11 */   _T("PREC"),
	/*  12 */   _T("RIGHT"),
	/*  13 */   _T("SEMI"),
	/*  14 */   _T("SEPARATOR"),
	/*  15 */   _T("START"),
	/*  16 */   _T("START_OPT"),
	/*  17 */   _T("SYNCH"),
	/*  18 */   _T("TERM_SPEC"),
	/*  19 */   _T("TYPE"),
	/*  20 */   _T("PERCENT_UNION"),
	/*  21 */   _T("WHITESPACE")
};


/*---------------------------------------------------------
 * The Yy_action table is action part of the LALR(1) transition
 * matrix. It's compressed and can be accessed using  the yy_next()
 * subroutine, declared below.
 * 
 *              Yya000[]={   3,   5,3   ,    2,2   ,   1,1   );
 *   state number---+        |    | |
 *   number of pairs in list-+    | |
 *   input symbol (terminal)------+ |
 *   action-------------------------+
 * 
 *   action = yy_next( Yy_action, cur_state, lookahead_symbol );
 * 
 *        action <  0   -- Reduce by production n,  n == -action.
 *        action == 0   -- Accept. ,(i.e Reduce by production 0.)
 *        action >  0   -- Shift to state n,  n == action.
 *        action == YYF -- error.
 */

YYPRIVATE YY_TTYPE Yya000[]={10, 14,-12 , 20,9   , 19,8   , 18,7   , 17,6   ,
			                 15,5   , 12,4   ,  8,3   ,  6,2   ,  2,1   
			                };
YYPRIVATE YY_TTYPE Yya002[]={12, 20,-59 , 19,-59 , 18,-59 , 17,-59 , 15,-59 ,
			                 14,-59 , 12,-59 ,  8,-59 ,  7,-59 ,  6,-59 ,
			                  5,-59 ,  2,-59 };
YYPRIVATE YY_TTYPE Yya003[]={12, 20,-55 , 19,-55 , 18,-55 , 17,-55 , 15,-55 ,
			                 14,-55 , 12,-55 ,  8,-55 ,  7,-55 ,  6,-55 ,
			                  5,-55 ,  2,-55 };
YYPRIVATE YY_TTYPE Yya004[]={12, 20,-57 , 19,-57 , 18,-57 , 17,-57 , 15,-57 ,
			                 14,-57 , 12,-57 ,  8,-57 ,  7,-57 ,  6,-57 ,
			                  5,-57 ,  2,-57 };
YYPRIVATE YY_TTYPE Yya005[]={11, 20,-53 , 19,-53 , 18,-53 , 17,-53 , 15,-53 ,
			                 14,-53 , 12,-53 ,  8,-53 ,  7,-53 ,  6,-53 ,
			                  2,-53 };
YYPRIVATE YY_TTYPE Yya006[]={11, 20,-25 , 19,-25 , 18,-25 , 17,-25 , 15,-25 ,
			                 14,-25 , 12,-25 ,  8,-25 ,  6,-25 ,  2,-25 ,
			                  7,16  };
YYPRIVATE YY_TTYPE Yya007[]={12, 20,-61 , 19,-61 , 18,-61 , 17,-61 , 15,-61 ,
			                 14,-61 , 12,-61 ,  8,-61 ,  7,-61 ,  6,-61 ,
			                  5,-61 ,  2,-61 };
YYPRIVATE YY_TTYPE Yya008[]={12, 20,-15 , 19,-15 , 18,-15 , 17,-15 , 15,-15 ,
			                 14,-15 , 12,-15 ,  8,-15 ,  6,-15 ,  2,-15 ,
			                  7,20  ,  5,19  };
YYPRIVATE YY_TTYPE Yya009[]={ 1,  1,22  };
YYPRIVATE YY_TTYPE Yya010[]={ 1, 14,23  };
YYPRIVATE YY_TTYPE Yya011[]={ 1, 14,-10 };
YYPRIVATE YY_TTYPE Yya012[]={12, 20,-21 , 19,-21 , 18,-21 , 17,-21 , 15,-21 ,
			                 14,-21 , 12,-21 ,  8,-21 ,  6,-21 ,  2,-21 ,
			                  7,25  ,  5,24  };
YYPRIVATE YY_TTYPE Yya015[]={11, 20,-23 , 19,-23 , 18,-23 , 17,-23 , 15,-23 ,
			                 14,-23 , 12,-23 ,  8,-23 ,  6,-23 ,  2,-23 ,
			                  7,29  };
YYPRIVATE YY_TTYPE Yya016[]={11, 20,-49 , 19,-49 , 18,-49 , 17,-49 , 15,-49 ,
			                 14,-49 , 12,-49 ,  8,-49 ,  7,-49 ,  6,-49 ,
			                  2,-49 };
YYPRIVATE YY_TTYPE Yya018[]={12, 20,-18 , 19,-18 , 18,-18 , 17,-18 , 15,-18 ,
			                 14,-18 , 12,-18 ,  8,-18 ,  6,-18 ,  2,-18 ,
			                  7,34  ,  5,33  };
YYPRIVATE YY_TTYPE Yya019[]={12, 20,-39 , 19,-39 , 18,-39 , 17,-39 , 15,-39 ,
			                 14,-39 , 12,-39 ,  8,-39 ,  7,-39 ,  6,-39 ,
			                  5,-39 ,  2,-39 };
YYPRIVATE YY_TTYPE Yya020[]={12, 20,-40 , 19,-40 , 18,-40 , 17,-40 , 15,-40 ,
			                 14,-40 , 12,-40 ,  8,-40 ,  7,-40 ,  6,-40 ,
			                  5,-40 ,  2,-40 };
YYPRIVATE YY_TTYPE Yya021[]={10, 20,-62 , 19,-62 , 18,-62 , 17,-62 , 15,-62 ,
			                 14,-62 , 12,-62 ,  8,-62 ,  6,-62 ,  2,-62 
			                };
YYPRIVATE YY_TTYPE Yya022[]={10, 20,-63 , 19,-63 , 18,-63 , 17,-63 , 15,-63 ,
			                 14,-63 , 12,-63 ,  8,-63 ,  6,-63 ,  2,-63 
			                };
YYPRIVATE YY_TTYPE Yya023[]={ 4, 14,-64 ,  7,-64 ,  5,-64 ,  0,-64 };
YYPRIVATE YY_TTYPE Yya024[]={12, 20,-41 , 19,-41 , 18,-41 , 17,-41 , 15,-41 ,
			                 14,-41 , 12,-41 ,  8,-41 ,  7,-41 ,  6,-41 ,
			                  5,-41 ,  2,-41 };
YYPRIVATE YY_TTYPE Yya025[]={12, 20,-42 , 19,-42 , 18,-42 , 17,-42 , 15,-42 ,
			                 14,-42 , 12,-42 ,  8,-42 ,  7,-42 ,  6,-42 ,
			                  5,-42 ,  2,-42 };
YYPRIVATE YY_TTYPE Yya026[]={10, 20,-58 , 19,-58 , 18,-58 , 17,-58 , 15,-58 ,
			                 14,-58 , 12,-58 ,  8,-58 ,  6,-58 ,  2,-58 
			                };
YYPRIVATE YY_TTYPE Yya027[]={10, 20,-54 , 19,-54 , 18,-54 , 17,-54 , 15,-54 ,
			                 14,-54 , 12,-54 ,  8,-54 ,  6,-54 ,  2,-54 
			                };
YYPRIVATE YY_TTYPE Yya028[]={10, 20,-56 , 19,-56 , 18,-56 , 17,-56 , 15,-56 ,
			                 14,-56 , 12,-56 ,  8,-56 ,  6,-56 ,  2,-56 
			                };
YYPRIVATE YY_TTYPE Yya032[]={ 1, 14,-3  };
YYPRIVATE YY_TTYPE Yya033[]={12, 20,-50 , 19,-50 , 18,-50 , 17,-50 , 15,-50 ,
			                 14,-50 , 12,-50 ,  8,-50 ,  7,-50 ,  6,-50 ,
			                  5,-50 ,  2,-50 };
YYPRIVATE YY_TTYPE Yya034[]={12, 20,-51 , 19,-51 , 18,-51 , 17,-51 , 15,-51 ,
			                 14,-51 , 12,-51 ,  8,-51 ,  7,-51 ,  6,-51 ,
			                  5,-51 ,  2,-51 };
YYPRIVATE YY_TTYPE Yya035[]={10, 20,-60 , 19,-60 , 18,-60 , 17,-60 , 15,-60 ,
			                 14,-60 , 12,-60 ,  8,-60 ,  6,-60 ,  2,-60 
			                };
YYPRIVATE YY_TTYPE Yya040[]={ 4, 14,-27 ,  0,-27 ,  7,57  ,  5,56  };
YYPRIVATE YY_TTYPE Yya046[]={10, 20,-22 , 19,-22 , 18,-22 , 17,-22 , 15,-22 ,
			                 14,-22 , 12,-22 ,  8,-22 ,  6,-22 ,  2,-22 
			                };
YYPRIVATE YY_TTYPE Yya047[]={ 1, 14,-11 };
YYPRIVATE YY_TTYPE Yya048[]={10, 20,-24 , 19,-24 , 18,-24 , 17,-24 , 15,-24 ,
			                 14,-24 , 12,-24 ,  8,-24 ,  6,-24 ,  2,-24 
			                };
YYPRIVATE YY_TTYPE Yya052[]={10, 20,-14 , 19,-14 , 18,-14 , 17,-14 , 15,-14 ,
			                 14,-14 , 12,-14 ,  8,-14 ,  6,-14 ,  2,-14 
			                };
YYPRIVATE YY_TTYPE Yya053[]={10, 20,-13 , 19,-13 , 18,-13 , 17,-13 , 15,-13 ,
			                 14,-13 , 12,-13 ,  8,-13 ,  6,-13 ,  2,-13 
			                };
YYPRIVATE YY_TTYPE Yya054[]={ 1, 14,-5  };
YYPRIVATE YY_TTYPE Yya055[]={ 1, 14,-4  };
YYPRIVATE YY_TTYPE Yya056[]={ 1,  3,-65 };
YYPRIVATE YY_TTYPE Yya057[]={ 1,  3,-66 };
YYPRIVATE YY_TTYPE Yya058[]={ 2, 14,-67 ,  0,-2  };
YYPRIVATE YY_TTYPE Yya060[]={10, 20,-20 , 19,-20 , 18,-20 , 17,-20 , 15,-20 ,
			                 14,-20 , 12,-20 ,  8,-20 ,  6,-20 ,  2,-20 
			                };
YYPRIVATE YY_TTYPE Yya061[]={10, 20,-19 , 19,-19 , 18,-19 , 17,-19 , 15,-19 ,
			                 14,-19 , 12,-19 ,  8,-19 ,  6,-19 ,  2,-19 
			                };
YYPRIVATE YY_TTYPE Yya062[]={ 1, 14,-7  };
YYPRIVATE YY_TTYPE Yya063[]={ 1, 14,-9  };
YYPRIVATE YY_TTYPE Yya064[]={ 1, 14,-8  };
YYPRIVATE YY_TTYPE Yya065[]={10, 20,-17 , 19,-17 , 18,-17 , 17,-17 , 15,-17 ,
			                 14,-17 , 12,-17 ,  8,-17 ,  6,-17 ,  2,-17 
			                };
YYPRIVATE YY_TTYPE Yya066[]={10, 20,-16 , 19,-16 , 18,-16 , 17,-16 , 15,-16 ,
			                 14,-16 , 12,-16 ,  8,-16 ,  6,-16 ,  2,-16 
			                };
YYPRIVATE YY_TTYPE Yya067[]={ 1, 14,-6  };
YYPRIVATE YY_TTYPE Yya068[]={ 1,  3,73  };
YYPRIVATE YY_TTYPE Yya069[]={ 1,  3,74  };
YYPRIVATE YY_TTYPE Yya070[]={ 1,  0,0   };
YYPRIVATE YY_TTYPE Yya071[]={ 1, 14,75  };
YYPRIVATE YY_TTYPE Yya072[]={ 2, 14,-26 ,  0,-26 };
YYPRIVATE YY_TTYPE Yya073[]={ 7, 16,-52 , 13,-52 , 11,-52 ,  9,-52 ,  7,-52 ,
			                  5,-52 ,  1,-52 };
YYPRIVATE YY_TTYPE Yya075[]={ 1,  0,-1  };
YYPRIVATE YY_TTYPE Yya076[]={ 4, 14,-29 ,  7,-29 ,  5,-29 ,  0,-29 };
YYPRIVATE YY_TTYPE Yya077[]={ 7, 13,-38 ,  9,-38 , 16,83  , 11,82  ,  7,81  ,
			                  5,80  ,  1,79  };
YYPRIVATE YY_TTYPE Yya078[]={ 4, 14,-28 ,  7,-28 ,  5,-28 ,  0,-28 };
YYPRIVATE YY_TTYPE Yya079[]={ 8, 16,-46 , 13,-46 , 11,-46 ,  9,-46 ,  7,-46 ,
			                  5,-46 ,  4,-46 ,  1,-46 };
YYPRIVATE YY_TTYPE Yya080[]={ 8, 16,-47 , 13,-47 , 11,-47 ,  9,-47 ,  7,-47 ,
			                  5,-47 ,  4,-47 ,  1,-47 };
YYPRIVATE YY_TTYPE Yya081[]={ 8, 16,-48 , 13,-48 , 11,-48 ,  9,-48 ,  7,-48 ,
			                  5,-48 ,  4,-48 ,  1,-48 };
YYPRIVATE YY_TTYPE Yya082[]={ 1,  7,88  };
YYPRIVATE YY_TTYPE Yya083[]={ 6, 16,-44 , 11,-44 ,  7,-44 ,  5,-44 ,  4,-44 ,
			                  1,-44 };
YYPRIVATE YY_TTYPE Yya084[]={ 2, 13,91  ,  9,90  };
YYPRIVATE YY_TTYPE Yya085[]={ 8, 13,-38 ,  9,-38 ,  4,-38 , 16,83  , 11,82  ,
			                  7,81  ,  5,80  ,  1,79  };
YYPRIVATE YY_TTYPE Yya088[]={ 8, 16,-45 , 13,-45 , 11,-45 ,  9,-45 ,  7,-45 ,
			                  5,-45 ,  4,-45 ,  1,-45 };
YYPRIVATE YY_TTYPE Yya089[]={ 6,  4,-38 , 16,83  , 11,82  ,  7,81  ,  5,80  ,
			                  1,79  };
YYPRIVATE YY_TTYPE Yya091[]={ 4, 14,-32 ,  7,-32 ,  5,-32 ,  0,-32 };
YYPRIVATE YY_TTYPE Yya092[]={ 4, 14,-30 ,  7,-30 ,  5,-30 ,  0,-30 };
YYPRIVATE YY_TTYPE Yya093[]={ 3, 13,-35 ,  9,-35 ,  4,-35 };
YYPRIVATE YY_TTYPE Yya094[]={ 3, 13,-34 ,  9,-34 ,  4,-34 };
YYPRIVATE YY_TTYPE Yya095[]={ 3, 13,-33 ,  9,-33 ,  4,-33 };
YYPRIVATE YY_TTYPE Yya097[]={ 1,  4,100 };
YYPRIVATE YY_TTYPE Yya098[]={ 4, 14,-31 ,  7,-31 ,  5,-31 ,  0,-31 };
YYPRIVATE YY_TTYPE Yya099[]={ 3, 13,-36 ,  9,-36 ,  4,-36 };
YYPRIVATE YY_TTYPE Yya100[]={ 8, 16,-43 , 13,-43 , 11,-43 ,  9,-43 ,  7,-43 ,
			                  5,-43 ,  4,-43 ,  1,-43 };
YYPRIVATE YY_TTYPE Yya102[]={ 3, 13,-37 ,  9,-37 ,  4,-37 };

YYPRIVATE YY_TTYPE *Yy_action[103] =
{
/*   0 */  Yya000, 
/*   1 */ Yya000, Yya002, Yya003, Yya004, Yya005, Yya006, Yya007, Yya008, 
/*   9 */ Yya009, Yya010, Yya011, Yya012, Yya012, Yya012, Yya015, Yya016, 
/*  17 */ Yya000, Yya018, Yya019, Yya020, Yya021, Yya022, Yya023, Yya024, 
/*  25 */ Yya025, Yya026, Yya027, Yya028, Yya015, Yya000, Yya006, Yya032, 
/*  33 */ Yya033, Yya034, Yya035, Yya008, Yya008, Yya000, Yya000, Yya040, 
/*  41 */ Yya012, Yya012, Yya000, Yya000, Yya000, Yya046, Yya047, Yya048, 
/*  49 */ Yya018, Yya018, Yya000, Yya052, Yya053, Yya054, Yya055, Yya056, 
/*  57 */ Yya057, Yya058, Yya040, Yya060, Yya061, Yya062, Yya063, Yya064, 
/*  65 */ Yya065, Yya066, Yya067, Yya068, Yya069, Yya070, Yya071, Yya072, 
/*  73 */ Yya073, Yya073, Yya075, Yya076, Yya077, Yya078, Yya079, Yya080, 
/*  81 */ Yya081, Yya082, Yya083, Yya084, Yya085, Yya085, Yya085, Yya088, 
/*  89 */ Yya089, Yya073, Yya091, Yya092, Yya093, Yya094, Yya095, Yya085, 
/*  97 */ Yya097, Yya098, Yya099, Yya100, Yya085, Yya102
};

/*---------------------------------------------------------
 * The  Yy_goto  table is goto part of the LALR(1) transition matrix
 * It's compressed and can be accessed using the yy_next() subroutine,
 * declared below.
 *  nonterminal = Yy_lhs[ production number by which we just reduced ]
 * 
 *                Yyg000[]={   3,   5,3   ,   2,2  ,   1,1   };
 *  uncovered state-+          |    | |
 *  number of pairs in list----+    | |
 *  nonterminal---------------------+ |
 *  goto this state-------------------+
 *  goto_state = yy_next( Yy_goto, cur_state, nonterminal );
 */

YYPRIVATE YY_TTYPE Yyg000[]={ 1,  1,10  };
YYPRIVATE YY_TTYPE Yyg001[]={ 1,  1,11  };
YYPRIVATE YY_TTYPE Yyg002[]={ 1, 33,12  };
YYPRIVATE YY_TTYPE Yyg003[]={ 1, 29,13  };
YYPRIVATE YY_TTYPE Yyg004[]={ 1, 31,14  };
YYPRIVATE YY_TTYPE Yyg005[]={ 1, 27,15  };
YYPRIVATE YY_TTYPE Yyg006[]={ 1,  4,17  };
YYPRIVATE YY_TTYPE Yyg007[]={ 1, 35,18  };
YYPRIVATE YY_TTYPE Yyg008[]={ 1,  5,21  };
YYPRIVATE YY_TTYPE Yyg012[]={ 1,  7,26  };
YYPRIVATE YY_TTYPE Yyg013[]={ 1,  7,27  };
YYPRIVATE YY_TTYPE Yyg014[]={ 1,  7,28  };
YYPRIVATE YY_TTYPE Yyg015[]={ 1,  8,30  };
YYPRIVATE YY_TTYPE Yyg016[]={ 1, 23,31  };
YYPRIVATE YY_TTYPE Yyg017[]={ 1,  1,32  };
YYPRIVATE YY_TTYPE Yyg018[]={ 1,  6,35  };
YYPRIVATE YY_TTYPE Yyg019[]={ 1, 13,36  };
YYPRIVATE YY_TTYPE Yyg020[]={ 1, 14,37  };
YYPRIVATE YY_TTYPE Yyg021[]={ 1, 36,38  };
YYPRIVATE YY_TTYPE Yyg022[]={ 1, 37,39  };
YYPRIVATE YY_TTYPE Yyg023[]={ 1, 38,40  };
YYPRIVATE YY_TTYPE Yyg024[]={ 1, 15,41  };
YYPRIVATE YY_TTYPE Yyg025[]={ 1, 16,42  };
YYPRIVATE YY_TTYPE Yyg026[]={ 1, 32,43  };
YYPRIVATE YY_TTYPE Yyg027[]={ 1, 28,44  };
YYPRIVATE YY_TTYPE Yyg028[]={ 1, 30,45  };
YYPRIVATE YY_TTYPE Yyg029[]={ 1,  8,46  };
YYPRIVATE YY_TTYPE Yyg030[]={ 1,  1,47  };
YYPRIVATE YY_TTYPE Yyg031[]={ 1,  4,48  };
YYPRIVATE YY_TTYPE Yyg033[]={ 1, 24,49  };
YYPRIVATE YY_TTYPE Yyg034[]={ 1, 25,50  };
YYPRIVATE YY_TTYPE Yyg035[]={ 1, 34,51  };
YYPRIVATE YY_TTYPE Yyg036[]={ 1,  5,52  };
YYPRIVATE YY_TTYPE Yyg037[]={ 1,  5,53  };
YYPRIVATE YY_TTYPE Yyg038[]={ 1,  1,54  };
YYPRIVATE YY_TTYPE Yyg039[]={ 1,  1,55  };
YYPRIVATE YY_TTYPE Yyg040[]={ 2,  9,59  ,  2,58  };
YYPRIVATE YY_TTYPE Yyg041[]={ 1,  7,60  };
YYPRIVATE YY_TTYPE Yyg042[]={ 1,  7,61  };
YYPRIVATE YY_TTYPE Yyg043[]={ 1,  1,62  };
YYPRIVATE YY_TTYPE Yyg044[]={ 1,  1,63  };
YYPRIVATE YY_TTYPE Yyg045[]={ 1,  1,64  };
YYPRIVATE YY_TTYPE Yyg049[]={ 1,  6,65  };
YYPRIVATE YY_TTYPE Yyg050[]={ 1,  6,66  };
YYPRIVATE YY_TTYPE Yyg051[]={ 1,  1,67  };
YYPRIVATE YY_TTYPE Yyg056[]={ 1, 39,68  };
YYPRIVATE YY_TTYPE Yyg057[]={ 1, 40,69  };
YYPRIVATE YY_TTYPE Yyg058[]={ 2, 41,71  ,  3,70  };
YYPRIVATE YY_TTYPE Yyg059[]={ 2,  9,59  ,  2,72  };
YYPRIVATE YY_TTYPE Yyg073[]={ 2, 26,77  , 10,76  };
YYPRIVATE YY_TTYPE Yyg074[]={ 2, 26,77  , 10,78  };
YYPRIVATE YY_TTYPE Yyg077[]={ 1, 11,84  };
YYPRIVATE YY_TTYPE Yyg079[]={ 1, 20,85  };
YYPRIVATE YY_TTYPE Yyg080[]={ 1, 21,86  };
YYPRIVATE YY_TTYPE Yyg081[]={ 1, 22,87  };
YYPRIVATE YY_TTYPE Yyg083[]={ 1, 18,89  };
YYPRIVATE YY_TTYPE Yyg084[]={ 1, 12,92  };
YYPRIVATE YY_TTYPE Yyg085[]={ 1, 11,93  };
YYPRIVATE YY_TTYPE Yyg086[]={ 1, 11,94  };
YYPRIVATE YY_TTYPE Yyg087[]={ 1, 11,95  };
YYPRIVATE YY_TTYPE Yyg088[]={ 1, 19,96  };
YYPRIVATE YY_TTYPE Yyg089[]={ 1, 11,97  };
YYPRIVATE YY_TTYPE Yyg090[]={ 2, 26,77  , 10,98  };
YYPRIVATE YY_TTYPE Yyg096[]={ 1, 11,99  };
YYPRIVATE YY_TTYPE Yyg100[]={ 1, 17,101 };
YYPRIVATE YY_TTYPE Yyg101[]={ 1, 11,102 };

YYPRIVATE YY_TTYPE *Yy_goto[103] =
{
/*   0 */  Yyg000, 
/*   1 */ Yyg001, Yyg002, Yyg003, Yyg004, Yyg005, Yyg006, Yyg007, Yyg008, 
/*   9 */  NULL,  NULL,  NULL, Yyg012, Yyg013, Yyg014, Yyg015, Yyg016, 
/*  17 */ Yyg017, Yyg018, Yyg019, Yyg020, Yyg021, Yyg022, Yyg023, Yyg024, 
/*  25 */ Yyg025, Yyg026, Yyg027, Yyg028, Yyg029, Yyg030, Yyg031,  NULL, 
/*  33 */ Yyg033, Yyg034, Yyg035, Yyg036, Yyg037, Yyg038, Yyg039, Yyg040, 
/*  41 */ Yyg041, Yyg042, Yyg043, Yyg044, Yyg045,  NULL,  NULL,  NULL, 
/*  49 */ Yyg049, Yyg050, Yyg051,  NULL,  NULL,  NULL,  NULL, Yyg056, 
/*  57 */ Yyg057, Yyg058, Yyg059,  NULL,  NULL,  NULL,  NULL,  NULL, 
/*  65 */  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, 
/*  73 */ Yyg073, Yyg074,  NULL,  NULL, Yyg077,  NULL, Yyg079, Yyg080, 
/*  81 */ Yyg081,  NULL, Yyg083, Yyg084, Yyg085, Yyg086, Yyg087, Yyg088, 
/*  89 */ Yyg089, Yyg090,  NULL,  NULL,  NULL,  NULL,  NULL, Yyg096, 
/*  97 */  NULL,  NULL,  NULL, Yyg100, Yyg101,  NULL
};

/*---------------------------------------------------------
 * The Yy_lhs array is used for reductions.It is indexed by production
 * number and holds the associated left-hand side adjusted so that the
 * number can be used as an index into Yy_goto.
 */

YYPRIVATE _TINT Yy_lhs[68] =
{
	/*   0 */	0,	/*   1 */	3,	/*   2 */	3,
	/*   3 */	1,	/*   4 */	1,	/*   5 */	1,
	/*   6 */	1,	/*   7 */	1,	/*   8 */	1,
	/*   9 */	1,	/*  10 */	1,	/*  11 */	1,
	/*  12 */	1,	/*  13 */	5,	/*  14 */	5,
	/*  15 */	5,	/*  16 */	6,	/*  17 */	6,
	/*  18 */	6,	/*  19 */	7,	/*  20 */	7,
	/*  21 */	7,	/*  22 */	8,	/*  23 */	8,
	/*  24 */	4,	/*  25 */	4,	/*  26 */	2,
	/*  27 */	2,	/*  28 */	9,	/*  29 */	9,
	/*  30 */	10,	/*  31 */	12,	/*  32 */	12,
	/*  33 */	11,	/*  34 */	11,	/*  35 */	11,
	/*  36 */	11,	/*  37 */	11,	/*  38 */	11,
	/*  39 */	13,	/*  40 */	14,	/*  41 */	15,
	/*  42 */	16,	/*  43 */	17,	/*  44 */	18,
	/*  45 */	19,	/*  46 */	20,	/*  47 */	21,
	/*  48 */	22,	/*  49 */	23,	/*  50 */	24,
	/*  51 */	25,	/*  52 */	26,	/*  53 */	27,
	/*  54 */	28,	/*  55 */	29,	/*  56 */	30,
	/*  57 */	31,	/*  58 */	32,	/*  59 */	33,
	/*  60 */	34,	/*  61 */	35,	/*  62 */	36,
	/*  63 */	37,	/*  64 */	38,	/*  65 */	39,
	/*  66 */	40,	/*  67 */	41
};

/*---------------------------------------------------------
 * The Yy_reduce[] array is indexed by production number and holds
 * the number of symbols on the right-hand side of the production
 */

 YYPRIVATE _TINT Yy_reduce[68] =
{
	/*   0 */	5,	/*   1 */	2,	/*   2 */	0,
	/*   3 */	3,	/*   4 */	4,	/*   5 */	4,
	/*   6 */	5,	/*   7 */	5,	/*   8 */	5,
	/*   9 */	5,	/*  10 */	2,	/*  11 */	4,
	/*  12 */	0,	/*  13 */	3,	/*  14 */	3,
	/*  15 */	0,	/*  16 */	3,	/*  17 */	3,
	/*  18 */	0,	/*  19 */	3,	/*  20 */	3,
	/*  21 */	0,	/*  22 */	2,	/*  23 */	0,
	/*  24 */	3,	/*  25 */	0,	/*  26 */	2,
	/*  27 */	0,	/*  28 */	4,	/*  29 */	4,
	/*  30 */	3,	/*  31 */	2,	/*  32 */	1,
	/*  33 */	3,	/*  34 */	3,	/*  35 */	3,
	/*  36 */	4,	/*  37 */	6,	/*  38 */	0,
	/*  39 */	0,	/*  40 */	0,	/*  41 */	0,
	/*  42 */	0,	/*  43 */	0,	/*  44 */	0,
	/*  45 */	0,	/*  46 */	0,	/*  47 */	0,
	/*  48 */	0,	/*  49 */	0,	/*  50 */	0,
	/*  51 */	0,	/*  52 */	0,	/*  53 */	0,
	/*  54 */	0,	/*  55 */	0,	/*  56 */	0,
	/*  57 */	0,	/*  58 */	0,	/*  59 */	0,
	/*  60 */	0,	/*  61 */	0,	/*  62 */	0,
	/*  63 */	0,	/*  64 */	0,	/*  65 */	0,
	/*  66 */	0,	/*  67 */	0
};
#ifdef YYDEBUG

/*---------------------------------------------------------
 * Yy_slhs[] is  a debugging version of Yy_lhs[]. It is indexed by
 * production number and evaluates to a string representing the
 * left-hand side of the production
 */

YYPRIVATE  _TCHAR  *Yy_slhs[68] =
{
	/*   0 */	"spec",
	/*   1 */	"end",
	/*   2 */	"end",
	/*   3 */	"defs",
	/*   4 */	"defs",
	/*   5 */	"defs",
	/*   6 */	"defs",
	/*   7 */	"defs",
	/*   8 */	"defs",
	/*   9 */	"defs",
	/*  10 */	"defs",
	/*  11 */	"defs",
	/*  12 */	"defs",
	/*  13 */	"fnames",
	/*  14 */	"fnames",
	/*  15 */	"fnames",
	/*  16 */	"tnames",
	/*  17 */	"tnames",
	/*  18 */	"tnames",
	/*  19 */	"pnames",
	/*  20 */	"pnames",
	/*  21 */	"pnames",
	/*  22 */	"opt_names",
	/*  23 */	"opt_names",
	/*  24 */	"snames",
	/*  25 */	"snames",
	/*  26 */	"rules",
	/*  27 */	"rules",
	/*  28 */	"rule",
	/*  29 */	"rule",
	/*  30 */	"right_sides",
	/*  31 */	"end_rhs",
	/*  32 */	"end_rhs",
	/*  33 */	"rhs",
	/*  34 */	"rhs",
	/*  35 */	"rhs",
	/*  36 */	"rhs",
	/*  37 */	"rhs",
	/*  38 */	"rhs",
	/*  39 */	"{14}",
	/*  40 */	"{13}",
	/*  41 */	"{18}",
	/*  42 */	"{17}",
	/*  43 */	"{28}",
	/*  44 */	"{27}",
	/*  45 */	"{26}",
	/*  46 */	"{25}",
	/*  47 */	"{24}",
	/*  48 */	"{23}",
	/*  49 */	"{19}",
	/*  50 */	"{16}",
	/*  51 */	"{15}",
	/*  52 */	"{22}",
	/*  53 */	"{12}",
	/*  54 */	"{11}",
	/*  55 */	"{10}",
	/*  56 */	"{9}",
	/*  57 */	"{8}",
	/*  58 */	"{7}",
	/*  59 */	"{6}",
	/*  60 */	"{5}",
	/*  61 */	"{4}",
	/*  62 */	"{3}",
	/*  63 */	"{2}",
	/*  64 */	"{0}",
	/*  65 */	"{21}",
	/*  66 */	"{20}",
	/*  67 */	"{1}"
};

/*---------------------------------------------------------
 * Yy_srhs[] is also used for debugging. It is indexed by production
 * number and evaluates to a string representing the right-hand side ofthe production.
 */

YYPRIVATE _TCHAR  *Yy_srhs[68] =
{
	/*   0 */	"defs SEPARATOR {0} rules end",
	/*   1 */	"{1} SEPARATOR",
	/*   2 */	"",
	/*   3 */	"SYNCH snames defs",
	/*   4 */	"PERCENT_UNION ACTION {2} defs",
	/*   5 */	"TYPE fnames {3} defs",
	/*   6 */	"TERM_SPEC {4} tnames {5} defs",
	/*   7 */	"LEFT {6} pnames {7} defs",
	/*   8 */	"RIGHT {8} pnames {9} defs",
	/*   9 */	"NONASSOC {10} pnames {11} defs",
	/*  10 */	"CODE_BLOCK defs",
	/*  11 */	"START {12} opt_names defs",
	/*  12 */	"",
	/*  13 */	"NAME {13} fnames",
	/*  14 */	"FIELD {14} fnames",
	/*  15 */	"",
	/*  16 */	"NAME {15} tnames",
	/*  17 */	"FIELD {16} tnames",
	/*  18 */	"",
	/*  19 */	"NAME {17} pnames",
	/*  20 */	"FIELD {18} pnames",
	/*  21 */	"",
	/*  22 */	"NAME opt_names",
	/*  23 */	"",
	/*  24 */	"NAME {19} snames",
	/*  25 */	"",
	/*  26 */	"rule rules",
	/*  27 */	"",
	/*  28 */	"NAME {20} COLON right_sides",
	/*  29 */	"FIELD {21} COLON right_sides",
	/*  30 */	"{22} rhs end_rhs",
	/*  31 */	"OR right_sides",
	/*  32 */	"SEMI",
	/*  33 */	"NAME {23} rhs",
	/*  34 */	"FIELD {24} rhs",
	/*  35 */	"ACTION {25} rhs",
	/*  36 */	"PREC NAME {26} rhs",
	/*  37 */	"START_OPT {27} rhs END_OPT {28} rhs",
	/*  38 */	"",
	/*  39 */	"",
	/*  40 */	"",
	/*  41 */	"",
	/*  42 */	"",
	/*  43 */	"",
	/*  44 */	"",
	/*  45 */	"",
	/*  46 */	"",
	/*  47 */	"",
	/*  48 */	"",
	/*  49 */	"",
	/*  50 */	"",
	/*  51 */	"",
	/*  52 */	"",
	/*  53 */	"",
	/*  54 */	"",
	/*  55 */	"",
	/*  56 */	"",
	/*  57 */	"",
	/*  58 */	"",
	/*  59 */	"",
	/*  60 */	"",
	/*  61 */	"",
	/*  62 */	"",
	/*  63 */	"",
	/*  64 */	"",
	/*  65 */	"",
	/*  66 */	"",
	/*  67 */	""
};
#endif


void yy_init_llama(yyvstype  *tovs)
{
   tovs->left = tovs->right = _T("");
}

_TCHAR *yypstk(yyvstype *tovs,_TCHAR *tods)
{
	static  _TCHAR buf[128];  /* Original : static  _TCHAR buf[128];*/

	if( *tovs->left || *tovs->right )
	{
		_stprintf(buf,_T("[%s,%s]"),tovs->left, tovs->right);
		return buf;
	}
	else
		return _T("");
}
						  
 void yy_init_occs(YYSTYPE *yylval)
{
  /* Called by yyparse just before it starts parsing      */

}
